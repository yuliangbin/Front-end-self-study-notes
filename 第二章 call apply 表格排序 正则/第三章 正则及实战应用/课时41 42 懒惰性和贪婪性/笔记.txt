=================== 课时 37 正则的作用 =============================
1、正则的作用:一个用来处理字符串的规则(正则就是用来处理字符串的)

2、判断一个字符串是否符合我们的规则
	reg.test(str);//返回值为true或false
	
3、正则的捕获:把字符串中符合我们正则规则的内容获取到
	reg.exec(str);

===================== 课时 38 正则的元字符和一些简单的应用 ===================
1、每一个正则表达式都是由元字符和修饰符组成

2、元字符
	在//之间具有特殊意义的字符。
	
3、具有特殊意义的元字符
	\	转义字符，转译后面字符所代表的含义
	^	以某一个字符开始
	$	以某一个字符结尾
	\n	匹配一个换行符
	.	除了\n以外的任意字符
	
4、代表出现次数的量词元字符
	*		出现0到多次
	+		出现1到多次
	?		出现0或1次
	{n}		出现n次
	{n,}	出现n到多次
	{n,m}	出现n到m次
	
5、	分组()	把一个大正则本身划分成几个小正则
		- let reg = /^(\d+)zhufeng(\d+)$/
	x|y		x或者y中的一个
	[xyz]	x、y、z中的一个
	[^xyz]	[]号里的^表示非，除了这三个字符以外的任意一个字符
	[a-z]	a-z之间的任何一个字符
	[^a-z]	除了a-z之间的任意一个字符
	\d		一个0-9之间的数字
	\b		匹配一个边界符(边界符即一个句子、单词等的边界)
	\w		数字、字母、下划线中的任意一个字符
	\s		匹配一个空白字符，空格，一个制表符，换页符

6、关于[],需要注意的点有:
	在[]内出现的所有字符都是代表其本身的意思，没有特殊的含义
	
7、分组的作用
	- 改变x|y的默认优先级
		let reg = /^18|19$/;
			//18 19 181 1819 119 819
		let reg = /^(18)|(19)$/;
			//18 19
		
	
8、练习
	有效数字的正则 正数 负数 零 小数
		12.3 0 -12 +23 0.5
	正号或负号可出现，也可不出现
	.可出现也可不出现，但一旦出现后面必须跟一位或多位数字
	整数部分，一个数可以是0-9，多位数字不能以0开头	




===================正则的创建方式==========================
1、字面量创建：
	var reg = /\wfsdfds/g;//知"fsdfds"是一个字符串。
		局限性：直接量创建的正则表达式只能是字符，和正则规定的语法(\w,[],\d等)，而不可以传变量
2、RegExp对象创建
	var reg = new RegExp("dsad",'g');/* /dsad/g */
	var test = "dfdsf",reg = RegExp(test);//知正则对象创建可以传变量
	reg = RegExp("\\d" + test + "\\d");//
	//在正则表达式中\后面接的是转义字符，因此要想字符\被转换为正确的正则表达式，需要对\进行转义，即'\\',否则会报错或者被忽略
		let reg = new RegExp('\d');//	\会被忽略
		let reg = new RegExp('\');//	\会报错，因为在转换为正则的时候\有特殊含义，需要被转义为\,
		
==================== 编写简单的正则表达式 ===========================
1、年龄介于18-56之间的数
	将数字划分为:18-19	20-49 50-56
	let reg = /(1[8-9]|[2-4]\d|5[0-6])/
	
2、中国的标准真实姓名
	let reg = /^[\u4e00-\u9fa5]{2,4}/
====================贪婪性和懒惰性=========================
1、exec():正则的捕获
	reg.exec(string)
	每一次捕获的时候都是先进行默认的匹配，如果没有匹配成功，捕获的结果为null，只有有匹配的内容时我们才能获取到。
	
	捕获的内容格式：捕获的内容格式是一个数组。
		0:		数组中的第一项是当前正则捕获的内容
		index：	捕获的内容在字符串中开始的索引位置
		input：	捕获的原始字符串
	正则匹配的特点：
		(1)懒惰性：在不进行任何处理的情况下，每一次执行exec只捕获第一个匹配的内容.
			dir(reg);	//属性lastIndex表示每次开始索引的位置。
		如何解决懒惰性：在正则的末尾加一个修饰符g。这样每执行一次exec，lastIndex都会指向当前已经索引到的位置。若已经匹配到最后一个正则，那么再执行一次exec会返回null(即没有匹配对象)。如果再执行一次，则会像一个闭环一样，下一次在执行exec时，会重新从索引为0的位置开始查找
			global:全局匹配 g
			ignoreCase:忽略大小写 i
			multiline:多行匹配 m
			
		(2)贪婪性：正则每一次捕获都是按照匹配最长的结果捕获的。
			例:2符合匹配规则，2015也符合匹配规则，但由于贪婪性，默认匹配2015
				let reg = /\d+/g;
				let str = 'zhudeng2015';
				console.log(reg.exec(str));//2015
				let reg = /\d+?/g;
				console.log(reg.exec(str));//2
			解决正则的贪婪性，在量词后面加一个?即可

2、我们知道，若想获得一个字符串的所有匹配项，我们必须执行多次exec()方法，因此我们可以写一个循环方法，一次性获得所有结果
	function reg(reg,str) {
		var arr = [];
		var res = reg.exec(str);
		while (res) {
			arr.push = res[0];
			res = reg.exec(str);
		}
		return arr;
	}
	
3、？在正则中的作用。
	(1)放在一个普通的元字符后面代表出现0-1次
	(2)放在一个量词的元字符后面是取消捕获时候的贪婪性
	
4、match():正则的捕获	
	和exec()不同的是，该方法是String对象的方法.且只执行一次就可以获取到所有匹配的结果
		形式为：string.match(reg).

>>>>>>>>可以看出似乎用match比exec好用，确实是这样的，但match也有自身的局限性，即在分组捕获的情况下，若只需要通过一次exec方法捕获就可以捕获到所有内容，则两者都能获取到小分组正则的内容。但对于exec方法必须通过多次捕获才能完全捕获到的内容，match只能捕获大正则匹配的内容，而对于小正则，捕获的内容是无法获取的。

==================分组捕获=========================
1、正则分组的作用	
	改变优先级
	分组引用
		\1表示和第一个出现的分组一模一样，\2表示和第二个出现的分组一模一样
2、分组捕获：正则在捕获的时候，不仅把大正则的内容捕获到，也会把小分组的正则的内容捕获到。
	var arr = reg.exec(string);//执行后获得的结果arr是一个数组,arr[0]表示大正则匹配的结果(即全局匹配的结果)，arr[1]表示第一个分组匹配的结果，arr[2]表示第二个分组匹配的结果。以此类推。
	在分组中的?=,表示只匹配不捕获.把只匹配不捕获的内容与?=放在同一个括号中。如(?=\d\d\.\d\d)，则表示该小数\d\d\.\d\d只匹配不捕获
	值得注意的是正则对象reg中的lastIndex对应的索引值是当前捕获的字符串的最后一个字符的索引的下一个，而不是当前正则匹配到的字符串最后一个字符的下一个。这一点当在使用了?=修饰符的正则表达式中需要特别注意
	 
	
	
	
	
	
	
	
	